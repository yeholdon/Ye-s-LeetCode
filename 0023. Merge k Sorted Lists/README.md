# 思路(C++)

## 一、暴力法

遍历所有链表，将它们的值都存到一个数组里，sort该数组然后再创建结果链表。Time Complexity:O(NlogN)

## 二、逐个比较

比较k条链表的头节点（最小节点），获取其中的最小节点，接到结果链表的末尾，然后将该节点从原链表删除（头节点移向下一个节点）。Time Complexity:O(kN)

## 三、用优先队列优化方法二

用有线队列优化方法二中，“比较k条链表的头节点（最小节点），获取其中的最小节点”的过程，可以将这些链表的头节点放入优先队列（小顶堆）中，降低复杂度。Time Complexity : O(Nlogk)

## 四、两两合并链表

将个链表两两合并k-1次，即将问题转换成了合并两个链表的问题。Time Complexity : O(kN)

## 五、分治法

将k个链表两个分组然后归并，得到k/2条链表，再分成k/4组两两归并得到k/4条链表。。。以此类推直到只剩一条链表即结果。Time Complexity : O(Nlogk)

不过比较奇怪的是，这里我用各种方式都试了试，反倒是方法四的执行时间最短。可能是因为这里的链表数k不够大，体现不出logk的优势，而其他方法的代价比较大，比如优先队列比较复杂等，导致了这种情况。