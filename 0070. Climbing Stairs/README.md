# 思路(C++)

## 一、动态规划

这题由于只要求方案个数，无需求所有方案中的最优方案，所以无需用DFS回溯法那样递归枚举所有可能。可以用动态规划的方法来解决。设dp[i]为爬到第i级楼梯的方案数，则`dp[i] = dp[i-1] + dp[i-2]`。边界条件为dp[0] = dp[1] = 1。

```cpp
#include <algorithm>

using namespace std;

class Solution {
public:
    int climbStairs(int n) {
        int a = 1, b = 1, c = 1;
        for (int i = 2; i <= n; i++)
        {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
};
```



 ## 二、通项公式

直接通过递推方程得到特征方程，然后得到通项公式，然后直接用公式计算，具体复杂度和具体CPU支持的指令集有关。这个方法涉及到数学知识，需要复习相关的数学才能理解。

## 三、矩阵快速幂

把求解转换为对2 * 2矩阵的幂的求解，然后利用数学上矩阵快速幂的算法，将时间复杂度由动态规划的O(n)优化为O(log n)

