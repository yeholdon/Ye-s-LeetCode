# 思路（C++)

这里有三个变量，理论上，可以按照twoSum的思路，只不过就是要多固定一个变量，多一层循环。但是由于这里的情况更复杂，数组里的数据有可能有重复，因此，twoSum里单纯地利用hashMap的方法就无效了，为了方便解决重复的情况，需要先对数组进行排序，将重复的元素都放到一起。方便处理。

- 首先，对数组进行排序，使得重复的元素在数组里的位置连续。
- 然后依次从头到尾（从小到大）遍历数组的元素。在外层循环内，triplet[0]固定(num[i])，这就变成了一个有序数组情况下的twoSum问题（当然，还存在元素重复的情况），有序情况下，可以用two pointers的思想，从num[i+1]和num[size - 1]开始向中间靠拢，知道找到两者之和等于-num[i]的情况。即找到一个答案。然后再继续向中心靠拢，直到two pointers合并。
- 为了解决重复问题，还要依次更新两个pointers，使得它们跳过剩下的重复元素，直到下一个不重复的元素。这里要注意判断是否重复的时候应当是nums[left]和triplet[1]比较，而非nums[left]和nums[left+1],因为这样的话到最后一个重复的元素就停止了。而我们的目标是到下一个不重复的元素位为止。
- triplet[0]也有可能重复，因此，在外层循环中，也要跳过重复的元素，在进入下一次循环。

时间复杂度：排序的O(nlogn) + 剩下的O(n^2) = O(n^2)