# 思路(C++)

## 思路一（转成string再reverse判断）

这个方法相当直接，借助stl秒杀，但是复杂度相对较高。O(N)

std::reverse()的用法：std::reverse(str.begin(), str.end())

## 思路二（除10获取reverse再比较）

这是一般的方式，复杂度O(logN)。但是这种方法要注意一个问题，比如2147483647这个数，已经是INT_MAX，在将其进行转置过程中，会出现已溢出，这是问题的根本所在，所以解决方法可以是在更新sum前判断是否可能溢出。

## 思路三（进一步优化，利用对称性）

同时通过x = x/10和sum * 10 + ｘ%10分别获取x的左半边和右半边倒置的值，然后判断是否一致。这样就能将时间复杂度减半。