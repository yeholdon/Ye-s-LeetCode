# 思路(C++)
这题看似简单，但是还是有些细节要注意，否则很可能耗费很多时间。
1. 首先就是这里给出的和要求返回的链表都是应该没有头节点的，但是如果没有头节点，处理起来又很麻烦。
所以就需要在结果链表有头节点的情况下返回无头节点的部分，其实也简单：只要在返回的时候返回头节点的下一个节点即可。
很多时候，我们也将这种没有存元素的节点称为dummy节点。
2. 还有就是进位问题，这个只要用一个carry变量存进位即可。
3. 最后，还有一点就是两条链表不等长的时候，当一条链表遍历完（当前节点为空），另一条还没遍历完的情况。
我的直观想法是分别判断两条链表等长和不等长的情况，然后处理节点值的和。但是，其实这题只要将空节点的元素值
的默认值设为0，然后在当前节点为空的时候不更新即可。
---
另外，对于进位的处理，直接用两个变量来作为进位和余数自然没问题。
另外STL里还有一个div_t结构体专门用来处理这个问题，结合<cstdlib>里的div()函数
可以方便地处理除法时商和余数的问题。其包含两个成员，分别是 quot(quotient) 与 rem(remainder). 
```cpp
std:div_t result = div(10, 3);
std:cout << result.quot << result.rem << std:endl;
```
