# 思路(C++)

## 一、暴力法

- 由于合法的子串只可能是成对的，因此暴力法就是枚举所有偶数长度的子串。然后逐个判断其是否是合法子串，同时更新所有遍历过的子串中合法子串的最大长度。

- 至于判断子串是否合法，只要用栈即可解决，碰到'('入栈，碰到')'出栈，如果碰到')'时栈已经为空，说明该子串不合法。最后遍历完整个子串，同时栈为空，则该子串合法。

时间复杂度：O(n^3)，会超时

## 二、动态规划

### 第一种

dp[i] [j]表示s[i...j]字串中未配对的'('数。这是我自己想的。时间复杂度为O(n^2).以下为代码。

```cpp
int longestValidParentheses(string s) {
    int len = s.size();
    vector<vector<int>> dp(len, vector<int>(len));
    vector<int> count(len);
    for (size_t i = 0; i < len; i++)
    {
        if (s[i] == '(')
        {
            dp[i][i] = 1;
        }
        else
        {
            dp[i][i] = 0;
        }
    }
    int max_len = 0;
    for (size_t i = 0; i < len; i++)
    {
        for (size_t j = i + 1; j < len; j++)
        {
            if (s[j] == '(')
            {
                dp[i][j] = dp[i][j - 1] + 1;
            }
            else
            {
                if (dp[i][j - 1] > 1)
                {
                    dp[i][j] = dp[i][j - 1] - 1;
                    count[i]++;
                }
                else if (dp[i][j - 1] == 1)
                {
                    dp[i][j] = dp[i][j - 1] - 1;
                    count[i]++;
                    max_len = max(max_len, count[i]);
                }
                else
                {
                    break;
                }
            }

        }
    }
    return max_len * 2;
}
```
### 第二种

dp[i]表示以索引位置i为结尾的最大合法子字符串的长度。对于每个dp元素的确定都要判断两个连续的字符。

1. dp[i] = dp[i-2] +２　如果

   s[i] = ')' 且s[i-1] = '(' ,即当前子串应该是"......()"的形式，这样就是简单的在dp[i-2]的基础上，末尾增加一对匹配的括号，即长度加2

2. dp[i] = dp[i-1] + 2 + dp[i - 2 - dp[i - 1]] 如果

   s[i] = ')' 且s[i-1] = ')', 即当前子串为"......))"的形式，这种情况下，如果s[i - dp[i-1] - 1] = '(', 则首先倒数第二个')'应该是某合法子串的一部分,记为subS(是它的最后一个')')，然后因为这个subS的前一个字符正好为'(' (因为s[i - dp[i-1] - 1] = '(' )，所以dp[i] 应该至少比dp[i-1] 多2.但是这还不够。因为以s[i-1]的这个')'作为结尾的最长合法子串subS可能是因为没有相应的')'与subS前面的那个'('匹配所以合法的子串就到subS为止，这时候由于增加了s[i]这个')'与subS前面的那个'('匹配了，在subS前面的那个'('之前的合法子串也应该加进来，与当前这个长度为dp[i-1]+2的合法子串连在一起合成一个总的合法子串。而在subS前面的那个'('之前的合法子串的长度应该为dp[i - 2 - dp[i-1]]，所以最终，dp[i]为两部分合成的结果 dp[i-1] + 2 + dp[i - 2 - dp[i - 1]]。

   #### 注意点

   这里我在写代码的时候遇到了一个大坑，非常难以发现，那就是要注意**无符号数与有符号数的运算结果为无符号数**。这会导致一个问题，就是当无符号数减去有符号数且实际结果小于0时，这时由于编译器会把结果作为无符号数看待，那么这个结果值就会是正的(最高位为1的无符号数为正数)，这样本来期望负值就变成了正值，导致出错。这也是max之类的函数要求输入的两个整数参数必须同为有符号数或者同为无符号数的原因。比如这里(i - dp[i - 1]) >= 2这个表达式，i是无符号的，dp[i-1]是有符号的，这样i - dp[i - 1]的值就会被认为是有符号的，这时，如果它的实际值为1，则这个表达式应该为false，但是当写成这样(i - dp[i - 1] - 2) >= 0时，就会出错，因为(i - dp[i - 1] - 2) 我们期望的值是-1但是因为它被看成了无符号数，则实际是int最大值-1为正数，那这个表达式的结果就会变成true。以后编程一定要注意这类问题，最好能不用无符号数的地方尽量就尽量用有符号数。

   时间复杂度O(n)

## 三、栈

> 该思路解答来自leetcode solution

通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。

具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

对于遇到的每个 ‘(’ ，我们将它的下标放入栈中
对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：

- 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
- 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」

我们从前往后遍历字符串并更新答案即可。

需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1的元素。

时间复杂度O(n)

## 四、基于计数的方法，无需额外空间

在此方法中，我们利用两个计数器 left 和 }right 。首先，我们从左到右遍历字符串，对于遇到的每个 ‘(’，我们增加left 计数器，对于遇到的每个 ‘)’ ，我们增加right 计数器。每当left 计数器与right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当right 计数器比left 计数器大时，我们将left 和right 计数器同时变回 00。

这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。

解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：

当 left 计数器比right 计数器大时，我们将left 和right 计数器同时变回 00
当 left 计数器与right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串
这样我们就能涵盖所有情况从而求解出答案。

这样时间复杂度为O(n),空间复杂度O(1)